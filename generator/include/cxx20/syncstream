#pragma once

#include <version>
#ifdef __cpp_lib_syncbuf
#include <syncstream>
#else
#include <mutex>
#include <sstream>
#include <unordered_map>
#endif

namespace cxx20 {

#ifdef __cpp_lib_syncbuf
  using osyncstream = std::osyncstream;
#else
  class osyncstream : public std::ostream {
  public:
    explicit osyncstream(std::ostream& output_stream) : std::ostream(&buffer_), output_(output_stream) {
    }
    ~osyncstream() {
      emit();
    }

    void emit() {
      static monitor<std::unordered_map<std::ostream*, std::mutex>> locks;

      std::stringbuf buffer;

      using std::swap;
      swap(buffer, buffer_);

      auto const locked = std::lock_guard{ locks([&](auto& map) -> decltype(auto) { return map[&output_]; }) };
      output_ << buffer.str();
    }

  private:
    template <class T> class monitor {
    public:
      template <class F> inline decltype(auto) operator()(F&& f) const {
        std::lock_guard guard{ mutex_ };
        return std::invoke(std::forward<F>(f), object_);
      }

    private:
      T mutable object_;
      std::mutex mutable mutex_;
    };

    std::stringbuf buffer_;
    std::ostream&  output_;
  };
#endif
} // namespace cxx20
