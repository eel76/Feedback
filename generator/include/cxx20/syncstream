#pragma once

#include <version>
#ifdef __cpp_lib_syncbuf
# include <syncstream>
#else
# include <mutex>
# include <sstream>
# include <unordered_map>
#endif

namespace cxx20 {

#ifdef __cpp_lib_syncbuf
  using osyncstream = std::osyncstream;
#else
  class osyncstream : public std::ostringstream
  {
  public:
    explicit osyncstream(std::ostream& output_stream)
      : output(output_stream)
    {
    }
    ~osyncstream()
    {
      emit();
    }

    void emit()
    {
      std::ostringstream const tmp{ std::move(*this) };

      static monitor<std::unordered_map<std::ostream*, std::mutex>> locks;

      auto const locked = std::lock_guard{ locks([&](auto& map) -> decltype (auto) { return map[&output]; }) };
      output << tmp.str();
    }

  private:
    template <class T> class monitor {
    public:
      template <class F> inline decltype (auto) operator()(F&& f) const {
        std::lock_guard guard{ mutex_ };
        return std::invoke(std::forward<F>(f), object_);
      }

    private:
      T mutable object_;
      std::mutex mutable mutex_;
    };

    std::ostream& output;
  };
#endif

} // namespace cxx20

